#include <iostream>
#include <vector>

using namespace std;


//동적 계획법
/*
복잡한 문제를 간단한 여러개의 부분 문제로 나누고, 부분 문제들을 각각 해결하여 전체 문제를 해결하는 방식
분할 정복법 에서는 분할된 부분들이 서로 곂치지 않지만 동적 계획법에서는 중복되는 부분 문제가 발생함
보통 최적화 문제와 카운팅 문제에 적용됨

유명한 동적계획법 문제들 리스트
0-1 배낭 문제 : 서로 다른 무게를 가진 물체가 있고 가방에 무게를 어떻게 분배해서 물건을 최대한 넣을지 계산
부분집합의 합 문제 : 정수 구성 집합, 임의의 집합이 주어질때 집합에 있는 정수들을 조합해서 주어진 정수를 만들수있는지
최장 공통 부분 시퀀스 : 두개의 문자열, 공통으로 존재하는 부분 문자열의 길이중 가장 긴 길이를 구하는것
연쇄 행렬 곱셈 : 크기가 다른 여러개의 행렬을 곱하는 식이 주어질때 어떠한 순서로 행렬을 곱했을때 곱셈 횟수가 어떻게 해야 가장 적은지 
최소 비용 경로 : 이차원 행렬이 주어질때, 좌상->우하로 이동할때 비용이 최소가 되는 구조 계산(최단거리, 그래프)
*/

//중복되는 부분문제
//최적 부분 구조
//이렇게 두가지가 동적 계획법의 필요조건이다.

//해결법
//기저조건(base case) 정의 
//상태전환(state transition)을 나타내는 순확식 정의
//순환식을 메모이제이션 또는 타뷸레이션 방식으로 풀이

//피보나치 수열 풀이가 대표적인 최적 부분 구조 해결법

//메모이제이션(memoization) - 중복 계산될수있는 값을 캐시에 저장하여 재사용, 하향식 접근방법
//피보나치 기준 중복된 모든 식을 배제할수있어서 O(n) 복잡도를 가짐

//타뷸레이션(tabulation) - 테이블이라 생각하면됨, 상향식, 연산결과를 미리 표(table)에 저장하여 사용하는 방식


/*
메모이 제이션 : 재귀호출이 많이발생, 함수 호출에 따른 오버헤드가 있음, 
                경우에 따라 모든 부분 문제를 풀지않아도 해답 구하기 가능, 
                캐시로 사용하는 표의 일부만 필요에 따라 계산하여 채움
타뷸레이션 : 표(배열)에 저장된 값을 참조하는 방식, 그러므로 빠르게 동작한다.
            상향식 방식이기 때문에 모든 부분 문제에 대한 해답을 구해서 표에 저장한다.
            표의 맨 처음부터 맨 끝까지 차례대로 계산하여 다 채운다.
*/

int fibo1(int n)
{
    if( n <= 1)
        return n;
    return fibo1(n - 1) + fibo1(n - 2); //앞의 두개를 더해서 새로운 항목을 만든다.
}

//메모이제이션의 표 구성
vector<int> memo(50,-1); //50개 -1로 초기화 생성

int fibo2(int n)
{
    if( n < 2)
        return n;
    
    if(memo[n] != -1) //만약 이미 방문해서 있다면 memo[n]의 값을 반환
        return memo[n];

    //이제 없을시
    memo[n] = fibo2(n-2) + fibo2(n-1);
    return memo[n];
}

//타뷸레이션
int fibo3(int n)
{
    vector<int> dp(n+1,0);
    dp[1] = 1;

    for(int i = 2; i<=n; i++)
    {
        dp[i] = dp[i-2] + dp[i-1];
    }

    return dp[n];
}

int main()
{
    int n = 5;
    cout << fibo1(n) << endl;
    cout << fibo2(n) << endl;
    cout << fibo3(n) << endl;
    return 0;
}